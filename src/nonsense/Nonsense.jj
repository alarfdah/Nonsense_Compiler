/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.8";
}

PARSER_BEGIN(NonsenseParser)
package nonsense;

import java.util.HashMap;

public final class NonsenseParser {

	public static String register[] = { "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi" };
	public static int regInUse[] = { 0, 0, 0, 0, 0, 0 };
	public static int offset = 4;
	public static HashMap<String, Integer> map;
	
	public static void main(String args[]) { 
	    NonsenseParser parser;
	    java.io.InputStream input;
	
	    if (args.length==1) {
	    
	      try {
	        input = new java.io.FileInputStream(args[args.length-1]);
	      } catch (java.io.FileNotFoundException e) {
	        System.out.println("File not found.");
	        return;
	      }
	      
	    } 
	    else {
	      System.out.println("Usage: nsc <inputfile>");
	      return;
	    }
	    try {
	      parser = new NonsenseParser(input);
	      System.out.println("\t.intel_syntax\n\t.section .rodata");
	      System.out.println(".io_format:\n\t.string \"%d\\12\\0\"");
	      System.out.println("\t.text\n\t.global main;\n\t.type main, @function");
	      System.out.println("main:\n\tpush %ebp\n\tmov %ebp, %esp\n\tsub %esp, 64");
	      System.out.println("\nMY_CODE_START\n");
	      map = new HashMap<String, Integer>();
	      parser.program();
	      System.out.println("\nMY_CODE_END\n");
	      System.out.println("leave\nret");
	    } catch (ParseException e) {
	      System.err.println("Syntax Error: "+e.getMessage());
	    }
	}

	public static String getFreeRegister(int reg) {
	  if (reg == -1) {
	    int i = 0;
	    for (i = 1; i < 6; i++) {
	      if (regInUse[i] == 0) {
	        regInUse[i] = 1;
	        return register[i];
	        }
	      }
	  } else {
	    regInUse[reg] = 1;
	    return register[reg];
	  }
	  
	  return "error";
	}

	public static void freeRegisters() {
	  int i = 0;
	  for (i = 1; i < 6; i++) {
	    if (regInUse[i] == 1) {
	      regInUse[i] = 0;
	    }
	  }
	}

	public static boolean isInt(String s) {
	    try {
	        Integer.parseInt(s);
	        return true;
	    } catch (NumberFormatException ex) {
	        return false;
	    }
	}
	
}

PARSER_END(NonsenseParser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
} 

TOKEN : /* keywords */
{
	<BEGIN: "begin">
    | <END: "end">
    | <OUTPUT: "output">
}

TOKEN : /* other lexical tokens */
{
 <EQ: "=">
| <SEMICOLON: ";">
| <LPAREN: "(">
| <RPAREN: ")">
| <PLUS: "+">
| <MINUS: "-">
| <TIMES: "*">
| <DIVIDE: "/">
| <EXP: "^">
| <#DIGIT: ["0" - "9"] >
| <#ALPHA: ["a" - "z"] | ["A" - "Z"] >
| <ID: <ALPHA> (<ALPHA> | <DIGIT>)*>
| <INT: "0" | ["1" - "9"](<DIGIT>)* >
}

void program(): {}
{
   <BEGIN> <SEMICOLON> 
   
   ( stmt() )*

   <END> <SEMICOLON>
    
}

void stmt() : {}

{
	( 
		assignment()
  		| output()
	)
	<SEMICOLON>

}

void assignment() : { Token x,y; String expr; int i = 0; }
{
  
  (
    x = <ID>
    <EQ>
    expr = expr()
    {
      System.out.printf("\tmov  dword ptr [%%ebp-%s], %s\n", offset, expr);
      map.put(x.image, offset);
      offset += 4;
      freeRegisters();
    }
  )
}

void output() : { String ret; }
{
	<OUTPUT> <LPAREN>
	(
	 ret = expr()
	) <RPAREN>
	{
	  System.out.println("\n\tpush dword ptr [%ebp-" + map.get(ret) + "]\n\tpush offset flat:.io_format");
	  System.out.println("\tcall printf\n\tadd %esp, 8\n");
	}
}


String expr() : { String x, y, addSub, reg = null; int i = 0;}
{
  (    x = term()
    
  )
  (
    LOOKAHEAD(2)
    addSub = addOp()
    y = term()
    {
      reg = getFreeRegister(-1);
//      System.out.println(x + " ----");
//      System.out.println(y + " ----");

      // Moving
      if (isInt(x)) {	// If constant
      	System.out.println("\tmov  " + reg + ", " + x);
      } else if (x.charAt(0) == '%') {	// If register
      	System.out.println("\tmov  " + reg + ", " + x);
      } else {	// If memory address
        System.out.println("\tmov  " + reg + ", dword ptr [%ebp-" + map.get(x) + "]");
      }

      // Adding
      if (isInt(y)) { // If constant
        System.out.println("\t" + addSub + "  " + reg + ", " + y);
      } else if (y.charAt(0) == '%') { // If register
        System.out.println("\t" + addSub + "  " + reg + ", " + y);
      } else { // If memory address
        System.out.println("\t" + addSub + "  " + reg + ", dword ptr [%ebp-" + map.get(y) + "]");
      }
      x = reg;  
    }
    
  )*
  {
    return x;
  }
} 

String term() : { String x, y, mulDiv, eax, reg; int i = 0; }
{
   (
     x = nterm()
   )
   (
     LOOKAHEAD(2)
     mulDiv = mulOp()
     y = nterm()
     {
       {
//      System.out.println(x + " ----");
//      System.out.println(y + " ----");

      
      switch(mulDiv) {
        case "imul":
          // Get free register
          reg = getFreeRegister(-1);
      
			// Moving
	      if (isInt(x)) {	// If constant
	      	System.out.println("\tmov  " + reg + ", " + x);
	      } else if (x.charAt(0) == '%') { // If register
	      	System.out.println("\tmov  " + reg + ", " + x);
	      } else { // If memory address
	        System.out.println("\tmov  " + reg + ", dword ptr [%ebp-" + map.get(x) + "]");
	      }
	
	      // Multiplying
	      if (isInt(y)) { // If constant
	        System.out.println("\t" + mulDiv + " " + reg + ", " + y);
	      } else if (y.charAt(0) == '%') { // If register
	        System.out.println("\t" + mulDiv + " " + reg + ", " + y);
	      } else { // If memory address
	        System.out.println("\t" + mulDiv + " " + reg + ", dword ptr [%ebp-" + map.get(y) + "]");
	      }
	      x = reg;
        break;
        case "idiv":
          // Use %eax
          eax = getFreeRegister(0);
          // Moving
	      if (isInt(x)) {	// If constant
	      	System.out.println("\tmov  " + eax + ", " + x);
	      } else if (x.charAt(0) == '%') { // If register
	      	System.out.println("\tmov  " + eax + ", " + x);
	      } else { // If memory address
	        System.out.println("\tmov  " + eax + ", dword ptr [%ebp-" + map.get(x) + "]");
	      }

	      // Dividing
	      if (isInt(y)) { // If constant
	        System.out.println("\tcdq\n\t" + mulDiv + " " + y);
	      } else if (y.charAt(0) == '%') { // If register
	        System.out.println("\tcdq\n\t" + mulDiv + " " + y);
	      } else { // If memory address
	      	reg = getFreeRegister(-1);
	      	System.out.println("\tmov  " + reg + ", dword ptr [%ebp-" + map.get(y) + "]");
	        System.out.println("\tcdq\n\t" + mulDiv + " " + reg);
	      }
	      x = eax;
        break;
      }
        
    }
     }
   )*

   {
     return x;
   }
}

String nterm() : { Token minus = null; String ret; }
{
	(
	  minus = <MINUS>
	)?
	(
	 ret = eterm()
	  {
	    if (minus != null) {
	      return "-" + ret;
	    }
	    return ret;
	  }
	)
}

String eterm() : { String ret; }
{
	(	  ret = factor()
	) ( <EXP> eterm() )?
	{
	    return ret;
	}
}

String factor() : { Token x = null, y = null; int i = 0; String reg = null;}
{
  (    x = <INT>
    { return x.image; }
  ) 
  |
  (
    y = <ID>
    { return y.image; }
  )
  | <LPAREN>
  (
    x.image = expr()
    {
      System.out.println("factor(expr()) = " + x.image);
    }
  ) <RPAREN>
  
}


String addOp() : { Token x = null; }
{
	(
	  x = <PLUS>
	  {
	    return "add";
	  }
	) 
	|
	(
	  x = <MINUS>
	  {
	    return "sub";
	  }
	)
}

String mulOp() : { Token x = null; }
{
	(	  x = <TIMES>
	  {
	    return "imul";
	  }
	)
	|
	(	  x = <DIVIDE>
	  {
	    return "idiv";
	  }
	)
}


